# Parsie

A Minimalist Parser and Compiler/code Generator with built-in VM Interpeter.

## Parser

The Parser uses a simple BNF-described grammar. It employes a recursive descent BNF-interpreter. Each rule use a single Capital character as it's name. If you want to match a capital it needs to be backquoted

    E=  expression...
    S=  statement..
    T=integer|string|real
    V=var %n: T = E; V | var %n:T; V |
    B=begin *V *S end
    P=procedure %n; B.
    S=\Foo\Bar

It'll backtrack when it doesn't match and will seek the next alternative "|" in the rule.

If a rule ends with "|" it allows match  with nothing, still satiesfying the rule. This is useful for doing list matching.

    L=foo,L|bar,L|L
    ?L
    foo,bar,bar,foo

### Input format
    # comment
    A=foo|bar|X         Any capital refs a rule
                        (X empty match "")
    ?A                  match rule A
    foo
    barf                leftover: f
    fie                 leftover: fie

    X=fieX|fumX|        Right recursion ok
    foo                 (still matching A)
    fum
    fiefumfie

    *A                  match A to rest of file
     fie                spaces ignored
    fum f i e           match> fie\nfum f i e<
    
### character classes
    %a = match alphabet and _
    %d = match digit
    %e = match end of text
    %w = match word char (alphanum _)
    %i = integer
    %n = identifier (%a%w...)

    ### string matcher
    ($1 always gives unquoted)
    (default is verbatim)

    %" = "foo\"bar"
    %' = 'c' or 'foo\'bar'
       (not handling nesting:???)
    %( = ( fo( oooo ( \) foo bar)
    %[ = [ fo[ oooo [ \] foo bar]
    %{ = { fo{ oooo { \} foo bar}
    %< = < fo< oooo < \> foo bar>
    %s = START fo? START \END foo bar END
	   handle any style string

### Regexp style
PREFIX regexp chars ? + * match optional, at least one, any number. This is greedy matching.

    //   ?R = optionall match rule R
    //   +R = match rule R once or more
    //   *R = match rule R 0 or more times
    //   (R must be a NonTerminal)

## Generating


The output generated by a rule is by default all text matched, but can be controlled by explicitly defining it per parse alternative:

# possible names of the project

small parser+interpreter:

grokie - to grok a little -ie
  this might be better as it also implies understanding. As it can interpret generated code once the input program is parsed - it "groks", at least a little bit.

parsie - small parser?

parslet - a tiny parser

pars - forth like 4th letters, lol
