# JS BNF -> ALF
# (from pascal.bnf)
#
# This file contains the BNF-parse rules for a limited subset of JavaScript
# For a legal and correct PASCAL program in the given subset, it will mostly
# behave the same. Maybe ;-)

# Capabilities
# - comments ^#cc ..// ../*cc*/.. ..(*cc*)..
# - integer/double/string/char "values"
# - {} objects w __proto__ and [] array!
# - "strings" are used, should be 'foo' or "foo"
# - "var" declare of single variable/init single variable
# - can define several functions/none
# - function only be named A-Z...
# - IF expr THEN stmts [ELSE stmt] supported
# - function call (in expressions, too)
# - return in functions
# - setting non-local use globals
# - expression operators: +-/* ()
# - logic: ! && (TODO: ||)
# - comparisions: === == <> <= < >= >
# - global variables and locals
# - "prepared" for scoped inner functions (TODO: not working yet)
# - recursive function calls - no problem

# Limitations/Features:
# - ,, in arrays not working at end?
# - non-existing functions == identity!
# - string stuff untested except for printing static strings
# - embryo for variable unlimited pascal/js strings includcing GC!

# TODO:
# - loops
# - process.stdout.write/
# - label+goto

# Parsing Rules:
#   (free rule chars: )

# TODO: these are needed, shouldn't be?
N=%n
D=%i

# this matches [] etc...?
K=%"|%'

# TODO: [] - Array(1,2,3)  how to do!
# TODO:
#  #, #> push    #< pop
#  #{ shift      #} unshift
#
# empty value ,, push? is undef?
# too many rules used
#
# TODO: BUG: [,,] cannot??
Q= E [$1] | [#undef]
F= , L [$1] |
L= Q F [$1 #< $2] | F [$1] |

# TODO: why overflow?
#L= Q ?, L [$1 #< #3] |


# Object construction
# TODO: , ,
B= N\:E ?, B [#$1 $2 #: $4] |

# lowest level
U= D [$1]
 | N\(A\) [$2$1]
 | N [$:1@]
 | \( E \) [$1]

# Multiplicative: * / div mod TODO: here?? "and"
T= U \* T [$1 $2 *]
 | U \/ T [$1 $2 /]
 | U [$1]

# Additive: + - TODO: here? "or"
E= \{ B \} [#^ $1]
 | \[ \] [#^]
 | \[ L B \] [#^ $1 $2]
 | T \+ E [$1 $2 +]
 | T \- E [$1 $2 -]
 | T [$1]
 | K [c$1]

# Relational: == <> < > <= >= in
# TODO: JS join with E
# TODO: add assignment
# TODO: == conversions? equal
Z= === [=] | == [=] | != [z] | <= [>z] | < | >= [<z] | >

# Logical negation: not
# TODO: E Z E may not work
# TODO: js no C just E...
C= E Z E [$1 $3 $2]
 | !C [$1~]
 | C && C [$1 $2 &]

# var...; var... ; lol TODO: only one, and many vars
V= var N\:Q=E; ::$1 V [$3 $:1! $4]
 | var N\:Q; V ::$1 [$3]
 |

I= if \(C\) S else S [$1?{$2}{$3}] | if \(C\) S [$1?{$2} ]

# formal arguments declaration
#   TODO: add types
W= ,H |
H= N W ::$1

# actual argument expression list
R= ,A [$1] |
A= E R [$1 $2] |

# statement is
#   TODO: a=b change to E?
S= \{ V G \} [$1 $2]
 | return E; [$1 ^]
 | console\.log\(K\); [$1]
 | console\.log\(E\); [$1.]
 | N\=E :=$1 [$2 $:1!]
 | I [$1]
 | do S while \(C\) [--DO-WHILE--]
 | while \(C\) S [--WHILE--]
 | for(S S S) [--FOR--]
 | N\(A\); [$2$1]
 | E [$1]
 
# BLOCK grouping of statement
G= S G [$1 $2] | ; |

# single function!
#   TODO: generalize
J= function N\(:E H\) \{ V G \} [:$1 $#\$\$ $3 $4^; ] :X J [$5] |

P= J S%e [$1 $2]

# assume statement parse
?S
