# JS BNF -> ALF
# (from pascal.bnf)
#
# This file contains the BNF-parse rules for a limited subset of JavaScript
# For a legal and correct PASCAL program in the given subset, it will mostly
# behave the same. Maybe ;-)

# Capabilities
# - integer/real/string/char "values"
# - "strings" are used, should be 'foo'
# - "var" declare of single variable/init single variable
# - can define several functions/none
# - function only be named A-Z...
# - IF expr THEN stmts [ELSE stmt] supported
# - function call (in expressions, too)
# - return in functions
# - setting non-local use globals
# - expression operators: +-/* ()
# - logic: ! && (TODO: ||)
# - comparisions: === == <> <= < >= >
# - global variables and locals
# - "prepared" for scoped inner functions (TODO: not working yet)
# - recursive function calls
# - Assign "Result:=42;" to set return value

# Limitations/Features:
# - (only integer/string constants)
# - no comments (TODO: preprocessing stage of parser?)
# - C style ; in IF statements, LOL. TODO: fix
# - (BUG: can have several VAR clauses, lol TODO: decl several vars)
# - non-existing functions == identity!
# - string stuff untested except for printing static strings
# - embryo for variable unlimited pascal/js strings includcing GC!

# TODO:
# - loops
# - process.stdout.write/
# - label+goto

# Parsing Rules:
#   (free rule chars: )


# TODO: preprocess comments?

# TODO: these are needed, shouldn't be?
N=%n
D=%i

# TODO: pascal string is '...'
K=%s

# TODO: [] - Array(1,2,3)  how to do!
# TODO:
#  #, #> push    #< pop
#  #{ shift      #} unshift
#
# empty value ,, push? is undef?
# too many rules used
#
# TODO: BUG: [,,] cannot??
Q= E [$1] | [#undef ]
F= , L [$1] |
L= Q F [d $1 s #> $2] | F
M= \[ L \] [#^ $1]

# Object construction
B= \N\:\E [d $2s$1s #!]
O= \{ B \} [#^ $1]

# lowest level
U= D [$1] | N\(A\) [$2$1] | N [$:1@] | \( E \) [$1]

# Multiplicative: * / div mod TODO: here? "and"
T= U \* T [$1 $2 *] | U \/ T [$1 $2 /] | U [$1]

# Additive: + - TODO: here? "or"
E= K [c$1] | T \+ E [$1 $2 +] | T \- E [$1 $2 -] | T [$1]

# Relational: == <> < > <= >= in
# TODO: JS join with E
# TODO: add assignment
# TODO: == conversions? equal
Z= === [=] | == [=] | != [z] | <= [>z] | < | >= [<z] | >

# Logical negation: not
# TODO: E Z E may not work
# TODO: js no C just E...
C= E Z E [$1 $3 $2] | !C [$1~] | C && C [$1 $2 &]

# var...; var... ; lol TODO: only one, and many vars
V= var N\:Q=E; ::$1 V [$3 $:1! $4] | var N\:Q; V ::$1 [$3] |

I= if \(C\) S else S [$1?{$2}{$3}] | if \(C\) S [$1?{$2} ]

# formal arguments declaration
#   TODO: add types
W= ,H |
H= N W ::$1

# actual argument expression list
R= ,A [$1] |
A= E R [$1 $2] |

# statement is
#   TODO: a=b change to E?
S= \{ V G \} [$1 $2] | return E; [$1 ^] | console\.log\(K\); [$1] | console\.log\(E\); [$1.] | N\=E :=$1 [$2 $:1!] | I [$1] | do S while \(C\) [--DO-WHILE--] | while \(C\) S [--WHILE--] | for(S S S) [--FOR--] | N\(A\); [$2$1]

# BLOCK grouping of statement
G= S G [$1 $2] | ; |

# single function!
#   TODO: generalize
J= function N\(:E H\) \{ V G \} [:$1 $#\$\$ $3 $4^; ] :X J [$5] |

P= J S%e [$1 $2]

?J
function F(n) { G(3); } function G(n) { return 42; }
function F(n) {  if (n==0) return 0;  else if (n==1) return 1;  else return F(n-1)+F(n-2); }
?S
console.log(F(42));

?L
1
1,2
1,2,3
# BUG: one undef
,
# BUG: gives a c ?
,,
# ok
,,3
1,,,,,,,,,,11

?M
[]
[1]
[1,2]
[1,2,3]
[1,,3]
[,2,3]
[1,2,,]
[,2,,4,]

# Read rest as file inputs as one "chunk" and parse all as pascal!
*P
function F(n) {  if (n==0) return 0;  else if (n==1) return 1;  else return F(n-1)+F(n-2); }
console.log(F(35));
